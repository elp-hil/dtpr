%% analysisSoftware.tex
%%

%% ==============
\chapter{Analysis software}
\label{ch:Analysis software}
%% ==============
  To analyse the data recorded by DAQ and ORCA software, completely new data structures fit to the needs of muon detection and coincidence analysis have been created. 
  Methods have been implemented to further investigate data stored inside those structures.
  %% ===========================
  \section{Data structure}
  \label{ch:Analysis software:sec:Data structure}
  %% ===========================
    All data from the IPE-servers arrives converted from ORCA-specific formatting to .root files. Hence, ROOT Methods are used to extract data from these structures, while most of these methods are implemented as part of the KaLi package in Kasper, which constitutes for a complete and closed data transfer protocol.
    Through those structures, data will be cached locally and can be analysed.\\
    Before heading to actual analysis, all data is stored in the runtime structures.
    Here, the newly written class {\bf event} with the following members comes into play.
    \begin{figure}
      \caption*{{\bf event} class members}
      \begin{itemize}
	\item fADCValue
    	\item fTimeSec
    	\item fTimeSubSec
    	\item fPanel
    	\item fSide
      \end{itemize}
    \end{figure}
    For each member, corresponding set- and get-methods have been implemented. Furthermore, the operators "<", "<=", ">", ">=", "==", and "-" have been overloaded to compare the timestamps of the event class. This was useful especially since ADCValues are merely used for plausibility checking the data but not for quantitative analysis. Doing so, events and the classes derived from them can easily be compared and searching becomes cleaner and clearer.\\
    Derived from the base event class are two more storage classes:\\
    {\bf panelEvent} storing the second ADCValue
    \begin{figure}
      \caption*{{\bf coincidentEvent} additional member}
      \begin{itemize}
	\item fADCValue2
      \end{itemize}
    \end{figure}
	
    and the common timestamp of events activating both panel sides and\\
    {\bf coincidentEvent} storing ADCValues of simultaneous events in multiple modules and the number of modules involved:
    \begin{figure}
      \caption*{{\bf coincidentEvent} additional members}
	\begin{itemize}
	  \item std::vector fADCValues
	  \item fnPanels
      \end{itemize}
    \end{figure}
    Every ORCA-run then utilizes the class {\bf run} storing the data of the .root files in vectors of events.
    Recorded events should already be filtered - only simultaneously occurring events on the two sides of the same module should be recorded. As, under conditions not known, single sided events are recorded as well, a software workaround is needed. All events of one side of the modules are scanned to find whether a corresponding event with the same timestamp exists on the other side. If so, a coincidentEvent is created and pushed back into the run's vector of coincident events corresponding to the module it occured in.
    Now, the user can decide on which modules to analyse with the setPanels() function. This can be done sequentially for multiple sets of modules without newly reading the run's data, as all the primary data is stored inside the event vector.
    \begin{figure}[h]
      \caption*{{\bf run} class members}
	\begin{itemize}
	  \item std::vector events
	  \item std::vector detectorEvents
	  \item std::vector eventsByPanels
	  \item std::vector coincidentEvents
	  \item std::vector selectedPanels
      \end{itemize}
    \end{figure}
    
    
  
  %% ===========================
  \section{Search Algorithms}
  \label{ch:Analysis software:sec:Search algorithms}
  %% ===========================
    To analyse data, at various points searches for events with a particular timestamp have to be performed. This was simplified by the time-sorted recording of events. A first implemetation to search for coincident events was done on the base of average frequency and its standard deviation. This algorithm proved as fast and stable, though well applicable only for two sets of timed events. That is why an advanced incremental method has been created. The number of modules is now limited only by the physically available memory and the speed is even higher.
      %% ===========================
      \subsection{Frequency Search}
      \label{ch:Analysis software:sec:Search algorithms:subsec:Frequency Search}
      %% ===========================
      As this algorithm was built to run on only two sets of data, it simply walks through one set incrementally and looks for corresponding data in the other. Latter is not done in a "dumb" way by incrementing through the second set as well, but by calculating the average frequency of events inside the set and performing an intelligent guess on that basis. If the guessed event shows a different timestamp, the algorithm will keep going forward or backward in time in steps of the frequency's standard deviation until the timestamp searched for is in between two steps. Lastly, simple incrementation is used to find out whether an event at the desired point in time exists or not.
      \begin{figure}
	\centering
      	\includegraphics[width = 0.9\textwidth]{graphics/frequencySearch.eps}
      \end{figure}
      %% ===========================
      \subsection{Incremental Search}
      \label{ch:Analysis software:sec:Search algorithms:subsec: Incremental Search}
      %% ===========================
      While the frequency search increments solely one dataset, the incremental search steps through all the event tress, incrementing the one with the smallest timestamp. It then compares all events to each other, writes out the coincident ones, if any, and goes on incrementing the next smallest stamp. This assures the finding of all coincident events while keeping the speed very high.
      \begin{figure}
	\centering
      	\includegraphics[width = 0.9 \textwidth]{graphics/incrementalSearch.eps}
      \end{figure} 
  %% ===========================
  \section{Member Functions of the class {\bf run}}
  \label{ch:Analysis software:sec:methods of the class run}
  %% ===========================  
  
    %% ===========================
    \subsection{Constructor run()}
    \label{ch:Analysis software:sec:methods of the class run:subsec:Constructor}
    %% ===========================  
    Whenever a new instance of "run" is created, the constructor is called. Arguments to be passed are a KaLi::KLRunIdentifier, basically a string distinctively naming the run to be analysed, such as "myo00000001", KaLi::KLDataManger, a class handling the download of the Files form IPE-servers and a toggle variable telling the constructor which data to read via the member function getRun() and what member functions to call afterwards:
    \begin{figure}
    \caption*{\bf Toggle Choices}
    	\begin{itemize}
    		\item {\bf 0:} Data is downloaded and both muon data and detector data are stored
    		\item {\bf 1:} Data is downloaded and only detector data is stored
    		\item {\bf 2:} Data is downloaded and only muon data is stored
    		\item {\bf 3:} Data is read from local file system, only muon data is stored
    	\end{itemize}
    \end{figure}
    
    %% ===========================
    \subsection{Destructor \~ run()}
    \label{ch:Analysis software:sec:methods of the class run:subsec:Constructor}
    %% ===========================
    The destructor deletes all the contents of the vectors of events and inherited classes and clears them afterwards before deleting the member RUN which in fact frees all the memory reserved by the KaLi classes.
    
    %% ===========================
    \subsection{getRun()}
    \label{ch:Analysis software:sec:methods of the class run:subsec:getRun()}
    %% ===========================  
    
    This sets the member KaLi::KLRun through the KaLi::KLDataManager and then returns its KaLi::KLRunEvents - these include all recorded events meaning also both the relevant KaLi::KLEnergyEvents and KaLi::KLVetoEvents. The getRun() function is used for example in the constructor to read the run's data.
    
    %% ===========================
    \subsection{getLocalRun()}
    \label{ch:Analysis software:sec:methods of the class run:subsec:getLocalRun()}
    %% ===========================  
    
    It is not always possible to read data from the file servers, example given were files too big leading to timeouts at least in older KaLi versions. That is why the getLocalRun() function was introduced reading data from the local filesystem via the KaLi::KLRunIdentifier. The path to the files needs to be adapted in the source code \todo{environment variable?}.
    
    %% ===========================
    \subsection{detectCoincidences()}
    \label{ch:Analysis software:sec:methods of the class run:subsec:detectCoincidences()}
    %% ===========================      
    
    After calling the member function channelCoincidences(), panelCoincidences(nPanels) is returned where nPanels defines, how many modules have to show coincidences for the counter to increment. 
    
    %% ===========================
    \subsection{channelCoincidences()}
    \label{ch:Analysis software:sec:methods of the class run:subsec:channelCoincidences()}
    %% ===========================  
    This {\bf always} clears the vector eventsByPanels before filling it according to the current selectedPanels settings. To do so, it loops over all entries of selectedPanels, calling loopOverSides() of the current module.
    
    %% ===========================
    \subsection{loopOverSides()}
    \label{ch:Analysis software:sec:methods of the class run:subsec:loopOverSides()}
    %% ===========================  
    
    Analysing only one of the modules for coincident events between the two sides, the function runs through all the events of one panel side using the operators "<" and "==" overloaded for the class run to compare event times. For the search itself, the "A" side's index is incremented step by step while the "B" side's index is pushed up as long as its event time is smaller than A's. Every time that condition changes, it checks whether the events occured at the same time - pushing a coincidentEvent with both the events ADCValues and the timestamp into the vector for the corresponding module if so - and then going on incrementing A's index.
    
    %% ===========================
    \subsection{panelCoincidences()}
    \label{ch:Analysis software:sec:methods of the class run:subsec:panelCoincidences()}
    %% ===========================  

    As mentioned above, the first algorithm to search for coincidences between different panels was based on the average event frequency and its standard deviation, soon beeing replaced by a simpler, more efficient incremental algorithm:
    This features a storage for the smallest timestamp in a group of events. \todo{change code to overl.ops} This is set to the smallest timestamp of the first event of all the modules analysed. Now, all the events are compared to the smallest one. This has the advantage, that one does not need to cross check every event with every other one but can simply compare every event to the smallest in a linear way. If simultaneous events are found, they are pushed back into the coincidentEvents vector together with the timestamp and their ADC values, nPanels is risen by one. Subsequently, the index of the smallest event storage is incremented and the new smallest event in the changed pool is searched for via the member function findSmallest(). This is repeated until all the event storages have reached their last entry.
    The return value is the number of events fulfilling the requirement passed through nPanels to panelCoincidences: if it is zero, every coincident event with two or more modules involved is counted, for every other number, only the number of event with exactly this number of modules is counted.
    
    %% ===========================
    \subsection{getSize()}
    \label{ch:Analysis software:sec:methods of the class run:subsec:getSize()}
    %% ===========================  
    The getSize() function returns the size of one of the vectors storing events or one of the inherited classes depending on the passed integer "what":
    \begin{figure}
    	\begin{itemize}
		
    		\item {\bf default/1:} Size of events returned
    		\item {\bf 2:} Size of eventsByPanels returned
    		\item {\bf 3:} Size of coincidentEvents returned
    		\item {\bf 4:} Size of detectorEvents returned
    	\end{itemize}

    \end{figure}

    \todo{default nonsense, reimplement}
    
    %% ===========================
    \subsection{readVetoEventData() and readDetectorData()}
    \label{ch:Analysis software:sec:methods of the class run:subsec:Member Functions readVetoEventData() and readDetectorData()}
    %% ===========================  
    Depending on the toggle choice in the constructor, either one of the two or both of the functions are called. While the readDetectorData() function reads all recorded KaLi::\-KLEnergy\-Events (only the FPD records those), the readVetoEventData() function reads all the KaLi::KLVetoEvents from cards three, six and nine. This can never interfere with veto data recorded directly around the FPD vor active vetoing, as cards 15 and 16 are used here. 

    
    
    
    
    
      